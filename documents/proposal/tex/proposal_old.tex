\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{xcolor,colortbl}
\usepackage{url}

\newcommand{\mc}[2]{\multicolumn{#1}{c}{#2}}
\definecolor{Gray}{gray}{0.85}

\newcolumntype{a}{>{\columncolor{Gray}}c}
\newcolumntype{b}{>{\columncolor{white}}c}

\newtheorem*{definition}{Definition}

\newtheorem*{theorem}{Theorem}

\title{project proposal for the CS260 course project}
\author{Osayd Abdu, Abdulelah Alneghaimish, Lukas Larisch, Elaf Islam, ? (TODO: student ids)}
\date{September 16, 2017}

\parindent 0pt

\begin{document}

\maketitle

\section{Introduction}

Our course project will cover the \underline{vertex cover} problem, a problem included in Karp's list of 21 NP-complete  problems \cite{karp, wiki}. We will implement two algorithms for finding a minimal vertex cover on general graphs: The first algorithm is an "direct" exponential time algorithm with running time TODO: running time, citation, the second algorithm solves the problem with help of tree decompositions \cite{survey, graphminor, arnborg}, which makes it possible to experimentally examine the constants hidded in Courcelle's theorem (1990):

\begin{theorem}
Every graph property definable in monadic second-order logic can be decided in linear time on graphs of bounded treewidth.
\end{theorem}

Hence, we will test our implementations graphs of bounded treewidth and random k-trees graphs, as well on general graphs generated by the GNP model and  e.g. "named" graphs as included in the SageMath package \cite{sagemath}.

\section{problem description}

In the following we use standard graph terminology \cite{Diestel}.

\begin{definition}

Given a (undirected) graph $G = (V, E)$, a \emph{vertex cover} $C$ of $G$ satisfies the following conditions:

\begin{itemize}
\item $C \subseteq V(G)$ 
\item $\{u, v\} \in E(G) \implies u \in C \lor v \in C$ 
\end{itemize}

A \emph{minimum vertex cover} is a vertex cover of minimum size among all vertex covers of $G$.

\end{definition}

Hence, a vertex cover $C$ of a graph $G$ is a subset of the vertices of $G$, such that all edges of $G$ have an endpoint in $C$. \\


\section{The algorithms}

\subsection{algo 1}

\subsection{algo 2}

The second algorithm solves the minimum vertex cover problem with help of tree decompositions.

\begin{definition}
A \emph{tree decomposition} of a graph $G$ is a pair $(T, \beta)$, where $T$ is a tree and $\beta: V(T) \rightarrow \mathcal{P}(V(G))$ is a map such that
\begin{itemize}
\setlength{\itemindent}{.2in}
\item [(T1)] for every edge $e \in E(G)$ there is a node $t \in V(T)$ with $e \subseteq \beta(t)$, $\quad$ and 
\item [(T2)] for all $v \in V(G)$ the set $\beta^{-1}(v) := \{t \in V(T) : v \in \beta(t)\}$ is non-empty and connected in $T$.
\end{itemize}

\vspace*{2mm}

We refer to the sets $\beta(t)$ of a tree decomposition as \emph{bags}. The width of a tree decomposition is it's maximal bag size minus 1. The \emph{treewidth} of $G$, $tw(G)$, is defined as the minimum width over all tree decompositions of $G$. \\
\end{definition}

The algorithm is an extension of the approach for solving the VC-problem on trees, i.e. a two-phase dynamic programming algorithm that, now on a treedecomposition, first creates tables for the powerset of the vertices contained in a bag. This is initally done for bags corresponding to leasf of a tree decomposition. Then, all vertex covers listed in the created tables will be extended, if possible, to vertex covers of a larger subgraph of the original graph in a bottom-up manner until the root of the tree decomposition is reached. In the second phase, an optimal vertex cover is computed by a top-down run beginning on the root of the tree decomposition which examines the computed tables until a leaf is reached. \\
The algorithm will work on \emph{nice tree decompositions}, i.e. rooted TD's with at most two childs per node and the feature that for nodes of degree 2, one bag is a subset of the "adjacent" bag and the "adjacent" bag contains exactly one more node of the graph. \\
For such type of TD's it is sufficient to state four rules on how to compute the tables within the algorithm. These four distinct rules are applicable on different types of nodes of a nice  treedecomposition, e.g. leafs or nodes with two childs (join nodes). \\
The algorithm has running time $\mathcal{O}(2^{tw(G)+1} \cdot n^{O(1)}$, hence is a polynomial time algorithm for graphs of bounded treewidth. \\ 

\bibliographystyle{plain}

\begin{thebibliography}{9}

\bibitem{karp} Karp, R. M. (1972). Reducibility Among Combinatorial Problems.. In R. E. Miller \& J. W. Thatcher (eds.), Complexity of Computer Computations (p./pp. 85-103), : Plenum Press, New York. ISBN: 0-306-30707-3

\bibitem{wiki} The vertex cover problem, \url{https://en.wikipedia.org/wiki/Vertex_cover}

\bibitem{Diestel} Diestel, R. (2005). Graph Theory. Springer-Verlag Heidelberg, New York. 

\bibitem{survey} H. L. Bodlaender, A tourist guide through treewidth, Acta Cybernetica

\bibitem{graphminor} Neil Robertson and P.D Seymour (1991), Graph minors. I. Excluding a forest, Journal of Combinatorial Theory, Series B, pp 39 - 61

\bibitem{arnborg} Stefan Arnborg (1985), Efficient Algorithms for Combinatorial Problems with Bounded Decomposability, BIT, pp 2--23

\bibitem{sage} SageMath, \url{http://www.sagemath.org/}

\end{thebibliography}

\end{document}