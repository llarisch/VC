\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{xcolor,colortbl}
\usepackage{url}

\newcommand{\mc}[2]{\multicolumn{#1}{c}{#2}}
\definecolor{Gray}{gray}{0.85}

\newcolumntype{a}{>{\columncolor{Gray}}c}
\newcolumntype{b}{>{\columncolor{white}}c}

\newtheorem*{definition}{Definition}
\newtheorem*{lemma}{Lemma}
\newtheorem*{theorem}{Theorem}
\newtheorem*{proposition}{Proposition}
\newtheorem*{proof_}{proof}

\DeclareMathOperator{\tw}{tw}
\DeclareMathOperator{\VC}{VC}
\DeclareMathOperator{\reach}{reach}

\title{midterm report for CS260: \\ \normalsize the vertex cover problem}
\author{Osayd Abdu (142461), Abdulelah Alneghaimish (159296), \\ Lukas Larisch (154273), Elaf Islam (142724)}
\date{date: ?}

\parindent 0pt

\begin{document}

\maketitle

\section{Introduction}

Our course project will cover the vertex cover problem, a problem included in Karp's list of 21 NP-complete  problems \cite{karp, wiki}. We will implement two algorithms for finding a minimal vertex cover on undirected graphs: The first algorithm with exponential running time uses a reduction from the max clique problem \cite{Patric}, the second algorithm solves the problem with help of tree decompositions \cite{survey, graphminor, arnborg}, which makes it possible to experimentally examine the constants hidded in Courcelle's theorem (1990):

\begin{theorem}
Every graph property definable in monadic second-order logic can be decided in linear time on graphs of bounded treewidth.
\end{theorem}

Hence, we will test our implementations on graphs of bounded treewidth and random k-trees graphs, as well on general graphs generated by the GNP model and  e.g. "named" graphs as included in the SageMath package \cite{sage}.

\section{Problem description}

In the following we use standard graph terminology \cite{Diestel}.

\begin{definition}

Given a (undirected) graph $G = (V, E)$, a \emph{vertex cover} $C$ of $G$ satisfies the following conditions:

\begin{itemize}
\item $C \subseteq V(G)$ 
\item $\{u, v\} \in E(G) \implies u \in C \lor v \in C$ 
\end{itemize}

A \emph{minimum vertex cover} is a vertex cover of minimum size among all vertex covers of $G$.

\end{definition}

Hence, a vertex cover $C$ of a graph $G$ is a subset of the vertices of $G$, such that all edges of $G$ have an endpoint in $C$. \\


\section{The algorithms}

\subsection{Algorithm 1}
The first algorithm solves the minimum vertex cover problem using a solution for the maximum clique problem.
\begin{definition}
A \emph{clique} $C$ of a graph $G=(V,E)$ satisfies the following conditions:

\begin{itemize}
\item $C \subseteq V(G)$
\item $u, v \in C \implies \{u, v\} \in E(G)$
\end{itemize}

A \emph{maximum clique} is a clique of maximum size among all cliques in $G$.
\end{definition}

In other words, a clique $C$ in a graph $G$ induces a complete subgraph in $G$. \\

We are going to use the reduction from the vertex cover problem to the maximum clique problem since both problems are NP-complete \cite{Patric}.\\

The algorithm for solving the maximum clique problem in a graph $G$ that Östergård suggested in 2002 starts from a vertex $v_i$, $i=n, \dots, 1$, $n :=|V(G)|$, and builds the largest clique that includes $v_i$ from the set of vertices $S_i = \{v_i, ..., v_n\}$. So, $S_n := \{v_n\}$ is considered first (clearly, $S_n$ is the largest clique itself). The algorithm then considers the largest clique in $S_{n-1}$ that contains $v_{n-1}$ and so on. The added advantage of this algorithm is the pruning strategy it uses to reduce the number of possible cliques.


\subsection{Algorithm 2}

The second algorithm solves the minimum vertex cover problem with help of tree decompositions. The algorithm is an extension of the approach for solving the VC-problem on trees, i.e. a two-phase dynamic programming algorithm that, now on a treedecomposition, first creates tables for the power set of the vertices contained in a bag. This is initially done for bags corresponding to leaves of a tree decomposition. Then, all vertex covers listed in the created tables will be extended, if possible, to vertex covers of a larger subgraph of the original graph in a bottom-up manner until the root of the tree decomposition is reached. In the second phase, an optimal vertex cover is computed by a top-down run beginning on the root of the tree decomposition which examines the computed tables until the leafs is reached. \\
The algorithm will work on \emph{nice tree decompositions}. For such type of TD's it is sufficient to state four rules on how to compute the tables within the algorithm. These four distinct rules are applicable on different types of nodes of a nice tree decomposition. The algorithm has running time $\mathcal{O}(2^{tw(G)+1} \cdot n^{O(1)})$, hence is a polynomial time algorithm for graphs of bounded treewidth. \\ 

\begin{definition}
A \emph{tree decomposition} of a graph $G$ is a pair $(T, \beta)$, where $T$ is a tree and $\beta: V(T) \rightarrow \mathcal{P}(V(G))$ is a map such that
\begin{itemize}
\setlength{\itemindent}{.2in}
\item [(T1)] for every edge $e \in E(G)$ there is a node $t \in V(T)$ with $e \subseteq \beta(t)$, $\quad$ and 
\item [(T2)] for all $v \in V(G)$ the set $\beta^{-1}(v) := \{t \in V(T) : v \in \beta(t)\}$ is non-empty and connected in $T$.
\end{itemize}

\vspace*{2mm}

We refer to the sets $\beta(t)$ of a tree decomposition as \emph{bags}. The width of a tree decomposition is it's maximal bag size minus 1. The \emph{treewidth} of $G$, $\tw(G)$, is defined as the minimum width over all tree decompositions of $G$. \\
\end{definition}

\begin{definition}
A tree decomposition $(T, \beta)$ of a graph $G$ is \emph{nice}, if it satisfies the following conditions: 

\begin{itemize}
\item $T$ is a rooted tree.
\item $d_{T}(t) \leq 2 \qquad \qquad$ f.a. $t \in V(T)$.
\item Every node $t \in V(T)$ is of one of the following types:
\begin{itemize}
\item [\textbf{leaf}] $t$ is a leaf of $T$ and $|\beta(t)| = 1$.
\item [\textbf{introduce}] $t$ has exactly one child $s$, $\beta(s) \subseteq \beta(t)$ and $|\beta(t)| = |\beta(s)| + 1$.
\item [\textbf{forget}] $t$ has exactly one child, $\beta(t) \subseteq \beta(s)$ and $|\beta(s)| = |\beta(t)| + 1$.
\item [\textbf{join}] $t$ has exactly two children $t_{1}, t_{2}$ and $\beta(t) = \beta(t_{1}) = \beta(t_{2})$.
\end{itemize}
\end{itemize}
 
\end{definition}

\begin{lemma}
Every graph $G$ with $V(G) \not = \emptyset$ has a nice tree decomposition of width $\tw(G)$.
\end{lemma}

\begin{proof}[sketch]
We apply the following transformations as long as possible. We will finally obtain a nice tree decomposition. \\

\textbf{Step 1:} Choose a root $r \in V(T)$ and orient all edges away from that root. \\

\textbf{Step 2:} If there is a node $t \in V(T)$ with more that two children, $\{t, s_{1}\}, \dots, \{t, s_{k}\} \in E(T)$ with $k > 2$, perform the following transformation: \\

\begin{itemize}
\item $E(T) := E(T) \backslash \{\{t, s_{i}\}, i \in \{2, \dots, k\}\}$.
\item subdivide $\{t, s_{1}\}$ resulting in a new node $u$ and the edges $\{t, u\}, \{u, s_{1}\}$.
\item $\beta(u) = \beta(t)$.
\item $E(T) := \{\{u, s_{i}\}, i \in \{2, \dots, k\}\}$.
\end{itemize}

\textbf{Step 3:} If there is a node $t$ with exactly 2 children $t_{1}, t_{2}$, such that $\beta(t) \not = \beta(t_{1})$ or $\beta(t) \not = \beta(t_{2})$, subdivide the edges $\{t, t_{i}\}, i \in \{1,2\}$, resulting in two new nodes $u_{1}, u_{2}$. Set $\beta(u_{i}) = \beta(t), i \in \{1,2\}$. Now, $t$ is an join node. We can procede with making the $u_{i}$'s forget or introduce nodes. \\

\textbf{Step 4:} Let $t$ be a node with exactly one child $s$. Let $\beta(t) \subseteq \beta(s)$ (the other case can be treated analogously). Let $M := \beta(s) \backslash \beta(t)$. If $|M| > 1$, then subdivide $\{t, s\}$, resulting in a new node $u$. Set $\beta(u) = \beta(t) \cup \{v\}$ for $v \in M$. \\

\textbf{Step 5:} Replace leaves by a sequence of introduce nodes: A leaf $t$ with $\beta(t) = \{v_{1}, \dots, v_{k}\}$ is replaced by a path $P := (t_{1}, \dots, t_{k})$ with $\beta(t_{i}) := \{v_{i}, \dots, v_{k}\}$.
\end{proof}

\begin{theorem}
Let $G$ be a graph. There is an algorithm that, given a nice tree decomposition $(T, \beta)$ of $G$ of width $\tw(G) =: k$, computes a minimum vertex cover of $G$ in running time $\mathcal{O}(2^{k+1} \cdot n^{\mathcal{O}(1)})$.
\end{theorem}

\begin{proof_}
Let $t \in V(T)$. By $R_{T}(t)$, we denote the set of vertices that are reachable from $t$, including $t$. Let $\beta(S) := \cup_{t \in S} \beta(t)$ for $S \in V(T)$. For $t \in V(T)$, let $G[t] := G[\beta(R_{T}(t))]$. \\

For $t \in V(T)$ and $X \subseteq \beta(t)$, let $\VC_{t}(X)$ be the minimum size of a vertex cover $X'$ in $G[t]$ with $X' \cap \beta(t) = X$, if such a $X'$ exists. Otherwise, $\VC_{t}(X) = \infty$. \\

Using the propositions below, we can compute $\VC(X)$ f.a. $X \subseteq \beta(t), t \in V(T)$ in time $n^{\mathcal{O}(1)} \cdot 2^{k+1}$. The size of a minimum vertex cover of $G$ is $\min_{X \in \beta(r)} \VC(X)$, were $r \in V(T)$ is the root of $T$. \\
We now can construct a minimum vertex cover by tracing back through the tree decomposition.

\begin{proposition}
\textbf{leaf:} Let $t$ be a leaf of $T$ with $\beta(t) = \{v\}$. Then $\VC(\{v\}) = 1$ and $\VC(\emptyset) = 0$. \qed
\end{proposition}

\begin{proposition}
\textbf{forget:} Let $t$ be a forget node of $T$ with child $s$ and $\beta(s) \backslash \beta(t) = \{v\}$. Then f.a. $X \in \beta(t), \VC(X) = \min \{\VC(X), \VC(X \cup \{v\})\}$.
\end{proposition}

\begin{proof}
Let $X'$ be a minimum vertex cover of $G[t] = G[s]$ with $X' \cap \beta(t) = X$. If $x \not \in X'$ then $X' \cap beta(s) = X$. Hence, $|X'| \geq \VC_{s}(X)$. If $x \in X'$, then $|X'| \geq \VC_{s}(X \cup \{v\})$ for the same reason. \\
Let $X_{1}, X_{2}$ be the vertex covers that determine $\VC_{t}(X),  \VC_{s}(X \cup \{v\})$. Both are vertex covers of $G[t]$. Hence, $\VC_{s}(X) \leq \min \{|X_{1}, X_{2}| \}$.
\end{proof}


\begin{proposition}
\textbf{introduce:} Let $t$ be an introduce node of $T$ with child $s$ and $\beta(t) \backslash \beta(s) = \{v\}$. Then f.a. $X \in \beta(t)$:

\begin{itemize}
\item [(1)] If $X$ is not a vertex cover of $G[\beta(t)]$ then $\VC_{t}(X) = \infty$. 
\item [(2)] If $X$ is a vertex cover of $G[\beta(t)]$ and $v \in X$ then $\VC_{t}(X) = \VC{s}(X \backslash \{v\}) + 1$.
\item [(3)] If $X$ is a vertex cover of $G[\beta(t)]$ and $v \not \in X$ then $\VC(X) = \VC(X)$.
\end{itemize}
\end{proposition}

\begin{proof}
(3): $N_{G[t]}(v) \subseteq \beta(s) \subset X$, since $X$ is a vertex cover of $G[\beta(t)]$.
\end{proof}


\begin{proposition}
\textbf{join:} Let $t$ be a join node of $T$ with children $s_{1}, s_{2}$. Then f.a. $X \in \beta(t)$, $\VC_{t}(X) = \VC{s_{1}}(X) + \VC_{s_{2}}(X) - |X|$.
\end{proposition}

\begin{proof}
If $X'$ is a vertex cover of $G[t]$ with $X' \cap \beta(t) = X$, then $X' \cap \beta(R_{T}(s_{i})$ is a vertex cover of $G[s_{i}], i \in \{1,2\}$. They share $|X|$ vertices. The vertex covers $X_{i}$ of $G[s_{i}]$ that are compatible with $X$ can be combined to a vertex cover of $G[t]$ of stated size.  \\
\end{proof}
\end{proof_}

\section{Implementations}

\begin{itemize}
\item C++
\item boost graphs
\item python interface
\item uses exact solver for tree decomposition problem (TdLib)
\end{itemize}

\section{Experiments}

\subsection{Test graphs}

\begin{itemize}
\item bounded treewidth
\item k-trees
\item GNP
\item named graphs
\end{itemize}

\subsection{Results}


\section{Summary}

\bibliographystyle{plain}

\begin{thebibliography}{9}

\bibitem{karp} Karp, R. M. (1972). Reducibility Among Combinatorial Problems.. In R. E. Miller \& J. W. Thatcher (eds.), Complexity of Computer Computations (p./pp. 85-103), : Plenum Press, New York. ISBN: 0-306-30707-3

\bibitem{wiki} The vertex cover problem, \url{https://en.wikipedia.org/wiki/Vertex_cover}

\bibitem{Diestel} Diestel, R. (2005). Graph Theory. Springer-Verlag Heidelberg, New York. 

\bibitem{survey} H. L. Bodlaender, A tourist guide through treewidth, Acta Cybernetica

\bibitem{graphminor} Neil Robertson and P.D Seymour (1991), Graph minors. I. Excluding a forest, Journal of Combinatorial Theory, Series B, pp 39 - 61

\bibitem{arnborg} Stefan Arnborg (1985), Efficient Algorithms for Combinatorial Problems with Bounded Decomposability, BIT, pp 2--23

\bibitem{sage} SageMath, \url{http://www.sagemath.org/}

\bibitem{Patric} Patric R.J. Östergård (2002), A fast algorithm for the maximum clique problem. Discrete Applied Mathematics

\end{thebibliography}

\end{document}